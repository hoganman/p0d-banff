/*! \mainpage BANFF

\section BANFF Introduction

TODO: Flesh out this introduction.

In short, the BANFF code has been reorganized into a more modular flexible framework,
which the user interacts with via one or more apps.  There are future plans for
complete control being possible entirely from a parameters or card file, but at
least for now there is some degree of coding involved to get running. The
following sections explain what you need to know to get started.

\section setup Setting up your toy throw/fit
See app/ThrowToys2013.cxx for an example for throwing toys, and
app/RunFit2013.cxx for an example for running a fit.  There are a number of
program parameters in parameters/BANFF.parameters.dat that control how each of
these apps operate.  The main things an app must take care of are discussed in
the following subsections.

\subsection obs Observables  
All observables are classes that inherit from BANFFObservableBase, 
and have a "GetCurrentValue()" method used by the BANFF
code to retrieve the value of the observable.

The observables are set up in ThrowToys2013.cxx in the following code section.
\code
    
    //Create instances of the observable classes we wish to use.
    psycheLeptonCandidateMomentum* pmu = new psycheLeptonCandidateMomentum();
    psycheLeptonCandidateCosTheta* thmu = new psycheLeptonCandidateCosTheta();

    //Create an array of observables with dimensionality of the number of
    //observables to use, and assign the observables as elements to this array.
    BANFFObservableBase** observables = new BANFFObservableBase*[2];
    observables[0] = pmu;
    observables[1] = thmu;
\endcode

The observables are created in the above code, and then assigned to a
BANFFObservableBase* array in order to be passed to the BANFF code.  There
is no need to have more than 1 instance of each observable you intend to use.
Similarly, if any of your samples use the same set of observables, the same
array of observables can be re-used for each sample (this is done in
ThrowToys2013.cxx, for example).

\subsection samples Samples
All samples are classes that inherit from BANFFSampleBase.  ThrowToys2013 makes
use of BANFFBinnedSample, which contains n-dimensional histograms (the user
specifies how many observables are considered for the sample, which will set
the histogram dimensionality).  Each sample
is a separate instance of this class.  In the case of BANFFBinnedSample, one
must define the desired binning for the histograms in the sample, as is done,
for example, for the CC0pi sample in ThrowToys2013.cxx here.
\code 

    //Define the binning desired for the histogram.
    Int_t npbins_0pi = 10;
    Double_t pbins_0pi[11] = {0.,300.,500.,600.,700.,900.,1000.,1500.,3000.,5000.,30000.}; // out to 30 and combine overflow
    Int_t nctbins_0pi = 7;
    Double_t ctbins_0pi[8] = {-1.0,0.6,0.8,0.85,0.90,0.94,0.98,1.0};

    //Create TAxis objects using that binning.
    TAxis* pAxis_0pi = new TAxis(npbins_0pi,pbins_0pi);
    TAxis* thAxis_0pi = new TAxis(nctbins_0pi, ctbins_0pi);
    
    //Create an array of TAxis pointers to hold these axes, to ultimately be
    //passed to the sample.  There must be the same number of axes as
    //observables.
    TAxis** cc0pi_axes = new TAxis*[2];
    cc0pi_axes[0] = pAxis_0pi;
    cc0pi_axes[1] = thAxis_0pi;

\endcode

Once the relevant sample information has been defined, the sample can then be
created with its constructor.  In ThrowToys2013.cxx, this is done for the CC0pi
sample as follows:
\code
    //Create the samples.
    //Supply the:
    //name
    //sampleID (in this case, the relevant sample enum value from psyche)
    //Number of observables.
    //Array of observables.
    //Axes for the histograms.
    //Whether to throw MC statistical errors.
    //Whether to throw statistical errors
    BANFFBinnedSample* cc0pi = new BANFFBinnedSample("cc0pi", nd280Samples::kFGD1NuMuCC0Pi, 2, observables, cc0pi_axes, true, false);

\endcode

Once all samples have been created, an array of BANFFSampleBase pointers must
be created, and the samples added to it:
\code
    BANFFSampleBase** samples = new BANFFSampleBase*[3];
    samples[0] = cc0pi;
    samples[1] = cc1pi;
    samples[2] = ccOth;
\endcode

\subsection fitparams Fit Parameters
The parameters that affect the MC prediction (and are thrown or fit) are
controlled from a class called FitParameters.  FitParameters contains a vector
of pointers to objects of classes derived from FitParameter.  Currently the
only way to set fit parameters is either through loading from a file (for flux,
XSec, and observable normalization parameters) or by setting the appropriate
option to load the detector parameters from the interface to the external
analysis code (e.g. psyche). 

Eventually some more fine tuning will be possible at the app level, but for now
there is just the ability to load parameters from an input file, as is done in
ThrowToys2013.cxx, for example.  The user thus decides whether to load these
parameters, where to load them from, and whether they are thrown/fitted.

A note on decomposition: When toys are being thrown, a Cholesky Decomposition
is automatically performed for the entire parameter set. For the fit the parameters to undergo
eigendecomposition must be specified manually, as is done in RunFit2013.cxx. 


\subsection interface Interface to the analysis
The BANFF framework contains an interface base class, BANFFInterfaceBase, which
contains the common functions that the BANFF code needs to throw
toys or perform the fit.  This is extended by psycheInterface, which handles
all the interfacing to the psyche code.  Since the sample information and the
fit parameter information is needed to create the interface, creating the
interface is done close to the end of the app, and fed this information.

\subsection toysOrFit Throw Toys or Run Fit
Once the interface has been created, you can either use the interface's built
in function to throw toys (see ThrowToys2013.cxx), or create an instance of the desired fitter
(Minuit2LikelihoodFit, see RunFit2013.cxx) and perform the fit.


\section performingFit Performing a 2013 style BANFF fit
The information in this section should translate the instructions from
BANFFv2's README into their BANFF v3 equivalent.

\subsection input Set up the input files
The input file listing is similar, but not identical to BANFFv2.  In the inputs
directory, run_periods.txt should be of the form:
\code
<Data File List 1> <MC File List 1> <Run period 1 name>
<Data File List 2> <MC File List 2> <Run period 2 name>
etc.
\endcode

where <Run period 1 name> is a string identifying the run period,
each <Data File List> is a text file of form:
\code
dataFile1.root
dataFile2.root
etc.
\endcode

and each <MC File List> is a text file of form:
\code
magnet1 mcFile1_withsplines.root
magnet2 mcFile2_withsplines.root
sand sandFile_withsplines.root
\endcode

(i.e. the main departure from 2013 is that the sand files are now broken out by
run period.)

NB: You may need to run apps from the input directory if you don't specify the
full path for the file lists.

\subsection psyche Set up psyche
In psycheSteering's parameter's file, make sure that you enable the appropriate
selection (in the case of the 2013 analysis, numuCCMultiPiSelection) and all of
the appropriate systematics.  (Currently this is all weight and all variation
systematics.)  Disable the FluxWeightSystematics, as BANFF currently uses its own
treatment for them.

\subsection throwtoys Throw Toys
Execute ThrowToys2013.exe with the following program parameter values.  (Note:
ThrowToys2013 can also accept a program parameter override file as an argument,
if you would rather specify a parameter file than use the contents of
BANFF.parameters.dat)
\code
< BANFF.InputFileList = <path to>/inputs/run_periods.txt >
< BANFF.FluxInputFile = <path to>/inputs/flux_covariance_banff_run1to4_v1.root >
< BANFF.XSecInputFile = <path to>/inputs/xsec_parameters_fsifirst.root >
< BANFF.ThrowToys.NToys = 2000 >
< BANFF.ThrowToys.OutputFile = toy_throws.root >
< BANFF.ThrowToys.ThrowMCStat = 1 >
< BANFF.ThrowToys.ThrowStat = 0 >
< BANFF.ThrowToys.LoadFluxParams = 1 >
< BANFF.ThrowToys.ThrowFluxParams = 0 >
< BANFF.ThrowToys.LoadXSecParams = 1 >
< BANFF.ThrowToys.ThrowXSecParams = 0 >
< BANFF.ThrowToys.LoadDetParams = 1 >
< BANFF.ThrowToys.ThrowDetParams = 1 >
< BANFF.ThrowToys.LoadObsNormParams = 0 >
< BANFF.ThrowToys.ThrowObsNormParams = 0 >
\endcode

\subsection toysToObsNorm Generate observable normalization parameters
Since Minuit has runs into difficulty with handling the event by event detector
systematic parameters due to bin migrations, this step takes the 2000 toys that
were thrown and uses them to generate the information needed to set up observable
normalization parameters which overall would affect the MC prediction in a
similar way to the detector systematics as a whole.  Simply run:
\code
BinnedToysToObsNormFile.exe toy_throws.root obsNormInput.root
\endcode

This will create the file obsNormInput.root, which contains the information
needed to generate these observable normalization parameters for the fit.
BinnedToysToObsNormFile.exe works with arbitrary numbers of samples and
observables (i.e. it should require no modification for other selections with
different observables, as long as you are using
BANFFBinnedSample to generate your toys.)

\subsection runFit Run the Fit
Execute RunFit2013.exe with the following program parameter values.  (Note:
RunFit2013 can also accept a program parameter override file as an argument,
if you would rather specify a parameter file than use the contents of
BANFF.parameters.dat)
\code
< BANFF.InputFileList = <path to>/inputs/run_periods.txt >
< BANFF.FluxInputFile = <path to>/inputs/flux_covariance_banff_run1to4_v1.root >
< BANFF.XSecInputFile = <path to>/inputs/xsec_parameters_fsifirst.root >
< BANFF.ObsNormInputFile = <path to>/obsNormInput.root >
< BANFF.RunFit.FitData = 1 >
< BANFF.RunFit.OutputFile = fit_output.root >
< BANFF.RunFit.ThrowMCStat = 0 >
< BANFF.RunFit.ThrowStat = 0 >
< BANFF.RunFit.LoadFluxParams = 1 >
< BANFF.RunFit.FitFluxParams = 1 >
< BANFF.RunFit.LoadXSecParams = 1 >
< BANFF.RunFit.FitXSecParams = 1 >
< BANFF.RunFit.LoadDetParams = 0 >
< BANFF.RunFit.FitDetParams = 0 >
< BANFF.RunFit.LoadObsNormParams = 1 >
< BANFF.RunFit.FitObsNormParams = 1 >
\endcode

NB: Although the above parameter set specified not to load the detector
parameters from psyche, and not to fit them, it is important that you maintain
the same configuration in the psycheSteering parameters file for the fit as you
used to throw the toys.  When events are processed from psyche into BANFF, a
detector weight is calculated based on nominal values of the detector
parameters, which may involve some corrections being applied.  When the fit is
run this should occur as well, otherwise the observable normalization
parameters will not be correct.


\section plots Viewing BANFFBinnedSample Output
The histograms produced by BANFFBinnedSample are objects of the ROOT THnD
class.  Since they are of arbitrary dimensionality, projecting them to a
specific dimension for drawing is required (even if they are only 2D plots:
ROOT does not try to guess what you want to see.)

To plot a 2D muon p-costheta histogram called cc0pi_data with costheta on the vertical axis and p
on the horizontal axis, issue the following command:
\code
cc0pi_data->Projection(1,0)->Draw("ZCOL")
\endcode
For more complicated projections, see the relevant ROOT documentation.
*/
